<script type="text/javascript">
/* eslint-disable */
	const replayDataElement = document.getElementById("replay-data");
	if (!replayDataElement) {
		console.error("replay-data element not found!");
		throw new Error("replay-data element not found");
	}
	
	const replayData = JSON.parse(replayDataElement.textContent);
	console.log("Replay data loaded:", {
		step: replayData.step,
		persona_count: Object.keys(replayData.persona_init_pos || {}).length,
		movement_steps: Object.keys(replayData.all_movement || {}).length
	});

	// Initialize variables from replay context
	let step = replayData.step;
	let step_size = replayData.sec_per_step * 1000; // Convert to milliseconds
	let zoom = replayData.zoom;
    if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;

	let tile_width = 32;
	let movement_speed = replayData.play_speed;
	let execute_count_max = tile_width / movement_speed;
	let execute_count = execute_count_max;
	let all_movement = replayData.all_movement;

	let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
	let start_datetime = new Date(Date.parse(replayData.start_datetime));

	// Persona related variables
	let persona_names = replayData.persona_init_pos;
	var spawn_tile_loc = {};
	for (var key in persona_names) {
		spawn_tile_loc[key] = persona_names[key];
	}
	console.log("Spawn tile locations:", spawn_tile_loc);

	var personas = {};
	var pronunciatios = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	const btnRun = document.getElementById("btn-run");
	const btnPause = document.getElementById("btn-pause");
	const btnShowChat = document.getElementById("btn-show-chat");
	const btnHideChat = document.getElementById("btn-hide-chat");
	const currentTimeLabel = document.getElementById("ui-current-time");
	const conversationPanel = document.getElementById("conversation-panel");
	let conversationVisible = true;

	let movement_target = {};
	const PERSONA_SCALE = 2;
	const PERSONA_BASE_BODY_WIDTH = 30;
	const PERSONA_BASE_BODY_HEIGHT = 40;
	const PERSONA_BASE_DISPLAY_WIDTH = 40;
	const PERSONA_LABEL_OFFSET_X = 15 * PERSONA_SCALE;
	const PERSONA_LABEL_OFFSET_Y = 25 * PERSONA_SCALE;

	let finished = false;
	let paused = false;

	const ZOOM_MIN = 0.3;
	const ZOOM_MAX = 2.5;
	const ZOOM_STEP = 0.05;

	const uiElements = [];
	const clampUiScale = (value) => Math.max(0.6, Math.min(1.5, value));
	let currentUiScale = clampUiScale(1 / zoom);

	function getConversationWrapWidth() {
		return Math.max(420, Math.min(window.innerWidth - 180, 900));
	}

	function clampZoom(value) {
		return Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, value));
	}

	function registerUiElement(element, depth = 10) {
		element.setDepth(depth);
		element.setScrollFactor(0);
		element.baseScale = element.scaleX || 1;
		element.setScale(element.baseScale * currentUiScale);
		uiElements.push(element);
		return element;
	}

function updateConversationLayout() {
	if (conversationPanel) {
		conversationPanel.style.maxWidth = getConversationWrapWidth() + "px";
	}
}

	function updateUiScale() {
		const targetScale = clampUiScale(1 / zoom);
		if (Math.abs(targetScale - currentUiScale) < 0.001) {
			return;
		}
		currentUiScale = targetScale;
		uiElements.forEach((element) => {
			if (element && element.setScale) {
				element.setScale(element.baseScale * currentUiScale);
			}
		});
		updateConversationLayout();
		if (currentTimeLabel) {
			currentTimeLabel.textContent = start_datetime.toLocaleTimeString("en-US", datetime_options);
		}
	}

	function applyZoom(newZoom) {
		zoom = clampZoom(newZoom);
		if (window.gameCamera) {
			window.gameCamera.setZoom(zoom);
		}
		updateUiScale();
	}

	btnRun.addEventListener("click", function() {
		if (finished) return;
		paused = false;
		btnRun.textContent = "[Run]";
		btnPause.textContent = " Pause ";
	});

	btnPause.addEventListener("click", function() {
		if (finished) return;
		paused = true;
		btnRun.textContent = " Run ";
		btnPause.textContent = "[Pause]";
	});

	btnShowChat.addEventListener("click", function() {
		conversationVisible = true;
		conversationPanel.classList.remove("hidden");
		btnShowChat.textContent = "[Show Chat]";
		btnHideChat.textContent = " Hide Chat ";
	});

	btnHideChat.addEventListener("click", function() {
		conversationVisible = false;
		conversationPanel.classList.add("hidden");
		btnShowChat.textContent = " Show Chat ";
		btnHideChat.textContent = "[Hide Chat]";
	});

	window.addEventListener("resize", () => {
		updateConversationLayout();
	});

	// Phaser configuration
	const config = {
		type: Phaser.AUTO,
		// width: 4480,
		// height: 3200,
        width: document.documentElement.clientWidth / zoom,
        height: document.documentElement.clientHeight / zoom,
		parent: "game-container",
        mode: Phaser.Scale.FIT,
		pixelArt: true,
		physics: {
			default: "arcade",
			arcade: {
				gravity: { y: 0 }
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		},
		scale: {
			zoom: zoom
		}
	};

	// Create Phaser game instance
	const game = new Phaser.Game(config);
	let cursors;
	let player;

	// Preload function
	function preload() {
		this.load.crossOrigin = "";

		// Load images
		this.load.image("blocks_1", "static/assets/village/tilemap/blocks_1.png");
		this.load.image("walls", "static/assets/village/tilemap/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "static/assets/village/tilemap/interiors_pt1.png");
		this.load.image("interiors_pt2", "static/assets/village/tilemap/interiors_pt2.png");
		this.load.image("interiors_pt3", "static/assets/village/tilemap/interiors_pt3.png");
		this.load.image("interiors_pt4", "static/assets/village/tilemap/interiors_pt4.png");
		this.load.image("interiors_pt5", "static/assets/village/tilemap/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "static/assets/village/tilemap/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "static/assets/village/tilemap/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "static/assets/village/tilemap/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "static/assets/village/tilemap/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "static/assets/village/tilemap/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "static/assets/village/tilemap/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "static/assets/village/tilemap/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "static/assets/village/tilemap/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "static/assets/village/tilemap/CuteRPG_Forest_C.png");

		// Load tilemap JSON
		this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap.json");

		this.load.atlas("atlas", "static/assets/village/agents/Ava_Lee/texture.png", filename="static/assets/village/agents/Ava_Lee/atlas.json");

		// Load persona atlases
		console.log("Loading persona textures, persona_names:", persona_names);
		for (var p in persona_names) {
			image_static = "static/assets/village/agents/" + p + "/texture.png";
			atlas_json = "static/assets/village/agents/" + p + "/atlas.json";
			console.log(`Loading atlas for ${p} from ${image_static} with ${atlas_json}`);
			this.load.atlas(p, image_static, atlas_json);
		}
	}

	// Create function
	function create() {
        const map = this.make.tilemap({ key: "map" });

        // 1. 把 Tiled 里的 tileset 都挂上
        //    注意第一个参数必须等于 Tiled 里 tileset 的 name
        const tsColumbia  = map.addTilesetImage("columbia_tiles_furnished", "columbia_tiles_furnished");
        const tsColumbia2 = map.addTilesetImage("columbia_tiles",           "columbia_tiles");
        const tsBlocks    = map.addTilesetImage("blocks_1",                 "blocks_1");
        const tsWalls     = map.addTilesetImage("Room_Builder_32x32",       "walls");
        const tsInt1      = map.addTilesetImage("interiors_pt1",            "interiors_pt1");
        const tsInt2      = map.addTilesetImage("interiors_pt2",            "interiors_pt2");
        const tsInt3      = map.addTilesetImage("interiors_pt3",            "interiors_pt3");
        const tsInt4      = map.addTilesetImage("interiors_pt4",            "interiors_pt4");
        const tsInt5      = map.addTilesetImage("interiors_pt5",            "interiors_pt5");
        const tsFieldB    = map.addTilesetImage("CuteRPG_Field_B",          "CuteRPG_Field_B");
        const tsFieldC    = map.addTilesetImage("CuteRPG_Field_C",          "CuteRPG_Field_C");
        const tsHarborC   = map.addTilesetImage("CuteRPG_Harbor_C",         "CuteRPG_Harbor_C");
        const tsVillageB  = map.addTilesetImage("CuteRPG_Village_B",        "CuteRPG_Village_B");
        const tsForestB   = map.addTilesetImage("CuteRPG_Forest_B",         "CuteRPG_Forest_B");
        const tsForestC   = map.addTilesetImage("CuteRPG_Forest_C",         "CuteRPG_Forest_C");
        const tsDesertB   = map.addTilesetImage("CuteRPG_Desert_B",         "CuteRPG_Desert_B");
        const tsDesertC   = map.addTilesetImage("CuteRPG_Desert_C",         "CuteRPG_Desert_C");
        const tsMountB    = map.addTilesetImage("CuteRPG_Mountains_B",      "CuteRPG_Mountains_B");

        // 一个 tileset 列表，所有 layer 都可以用它们（用多了没关系）
        const allTilesets = [
            tsColumbia, tsColumbia2, tsBlocks, tsWalls,
            tsInt1, tsInt2, tsInt3, tsInt4, tsInt5,
            tsFieldB, tsFieldC, tsHarborC, tsVillageB,
            tsForestB, tsForestC, tsDesertB, tsDesertC, tsMountB,
        ];

        // 2. 创建所有图层：Ground + 各种 1xxx / 2xxx / 3xxx
        //    Ground 在最底，其他层按 Tiled 里的顺序往上叠
        let groundLayer = null;
        map.layers.forEach(layerData => {
            const name = layerData.name;
            if (name === "Ground") {
                groundLayer = map.createLayer(name, allTilesets, 0, 0);
                groundLayer.setDepth(-2);
            } else {
                const l = map.createLayer(name, allTilesets, 0, 0);
                l.setDepth(0);   // 以后你可以按 1/2/3 调整 depth
            }
        });

		const canvas = game.canvas;
		canvas.addEventListener("wheel", (event) => {
			event.preventDefault();
			event.stopPropagation();
			const delta = event.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
			applyZoom(zoom + delta);
		}, { passive: false });

		function add_text(game, x, y, text, background, options = {}) {
			const wrapWidth = options.wrapWidth || 1000;
			const depth = options.depth || 10;
			res = game.add.text(
				x,
				y,
				text,
				{
					font: "24px 黑体",
					fontWeight: "normal",
					fill: "#000000",
					backgroundColor: background,
					padding: { x: 20, y: 4},
					align: "left",
					wordWrap: { width: wrapWidth, useAdvancedWrap: true },
				}
			);

			res.alpha = 0.8;
			return registerUiElement(res, depth);
		}

		updateConversationLayout();

		// Setup camera
		player = this.physics.add.sprite(2440, 500, "atlas", "down").setSize(30, 40).setOffset(0, 0);
		player.setDepth(-1);
		const camera = this.cameras.main;
		camera.startFollow(player);
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		cursors = this.input.keyboard.createCursorKeys();
		window.gameCamera = camera;

		// Setup personas
		// We start by creating the game sprite objects.
		console.log("Creating personas, spawn_tile_loc:", spawn_tile_loc);
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			console.log(`Creating ${persona_name} at position [${start_pos[0]}, ${start_pos[1]}]`);
			
			// Check if texture exists
			if (!this.textures.exists(persona_name)) {
				console.error(`Texture '${persona_name}' not found! Available textures:`, this.textures.list);
				continue;
			}
			
			let new_sprite = this.physics.add
				.sprite(start_pos[0], start_pos[1], persona_name, "down")
				.setSize(PERSONA_BASE_BODY_WIDTH * PERSONA_SCALE, PERSONA_BASE_BODY_HEIGHT * PERSONA_SCALE)
				.setOffset(0, 0);
			// Scale up the sprite
			new_sprite.displayWidth = PERSONA_BASE_DISPLAY_WIDTH * PERSONA_SCALE;
			new_sprite.scaleY = new_sprite.scaleX;
			// Set depth to be above foreground layers
			new_sprite.setDepth(1.5);

			// Here, we are creating the persona and its pronunciatio sprites.
			personas[persona_name] = new_sprite;
			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - PERSONA_LABEL_OFFSET_X,
				new_sprite.body.y - PERSONA_LABEL_OFFSET_X - PERSONA_LABEL_OFFSET_Y,
				"",
				{
					font: "18px monospace",
					fill: "#000000",
					backgroundColor: "#ffffcc",
					padding: { x: 4, y: 4},
					border:"solid",
					borderRadius:"10px"
				}
			).setDepth(3);
			pronunciatios[persona_name].alpha = 0.7;
			
			// Initialize movement_target with current position
			movement_target[persona_name] = [start_pos[0], start_pos[1]];
			
			console.log(`Successfully created ${persona_name} sprite`);
		}
		console.log(`Total personas created: ${Object.keys(personas).length}`);

		// Create animations
		const anims = this.anims;
		for (let i = 0; i < Object.keys(persona_names).length; i++) {
			let persona_name = Object.keys(persona_names)[i];
			let left_walk_name = persona_name + "-left-walk";
			let right_walk_name = persona_name + "-right-walk";
			let down_walk_name = persona_name + "-down-walk";
			let up_walk_name = persona_name + "-up-walk";

			frameRate = 4;
			if (movement_speed > 1) frameRate = 8;

			anims.create({
				key: left_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "left-walk.", start: 0, end: 2, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: right_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "right-walk.", start: 0, end: 2, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: down_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "down-walk.", start: 0, end: 2, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: up_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "up-walk.", start: 0, end: 2, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});
		}
	}

	// Update function
	function update(time, delta) {
		// Move camera
		const camera_speed = 400;
		player.body.setVelocity(0);
		if (cursors.left.isDown) {
			player.body.setVelocityX(-camera_speed);
		}
		if (cursors.right.isDown) {
			player.body.setVelocityX(camera_speed);
		}
		if (cursors.up.isDown) {
			player.body.setVelocityY(-camera_speed);
		}
		if (cursors.down.isDown) {
			player.body.setVelocityY(camera_speed);
		}

		let curr_focused_persona = document.getElementById("temp_focus").textContent;
		if (curr_focused_persona != "") {
			player.body.x = personas[curr_focused_persona].body.x;
			player.body.y = personas[curr_focused_persona].body.y;
			document.getElementById("temp_focus").innerHTML = "";
		}

		if (finished || paused) {
			return;
		}

		curr_datetime = new Date(start_datetime.getTime());
		curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
		curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
		curr_day = curr_datetime.getDate().toString().padStart(2, "0");
		curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
		curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");
		conversation_key = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;
		conversation_key_text = all_movement["conversation"][conversation_key];
		if (conversation_key_text && conversation_key_text != "") {
			conversationPanel.textContent = `${conversation_key} Conversation:\n${conversation_key_text}`;
		} else if (conversationVisible) {
			conversationPanel.textContent = "--";
		}

		// Moving personas
		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[Object.keys(personas)[i]];

			if (step in all_movement) {
				if (curr_persona_name in all_movement[step]) {
					if (execute_count == execute_count_max) {
						let curr_x = all_movement[step][curr_persona_name]["movement"][0];
						let curr_y = all_movement[step][curr_persona_name]["movement"][1];
						movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

						let action = all_movement[step][curr_persona_name]["action"];

						let act = action;
						act = act.length > 25 ? act.substring(0, 20)+"..." : act;
						pronunciatios[curr_persona_name].setText(curr_persona_name + ": " + act);

						// Updating the status of each personas
						document.getElementById("agent_desc__"+curr_persona_name).innerHTML = all_movement["description"][curr_persona_name]["currently"];
						document.getElementById("current_action__"+curr_persona_name).innerHTML = action;
						document.getElementById("target_address__"+curr_persona_name).innerHTML = all_movement[step][curr_persona_name]["location"];
					}

					if (execute_count > 0 && movement_target[curr_persona_name]) {
						let target_x = movement_target[curr_persona_name][0];
						let target_y = movement_target[curr_persona_name][1];
						
						if (curr_persona.body.x < target_x) {
							curr_persona.body.x += movement_speed;
							anims_direction = "r";
							pre_anims_direction = "r";
							pre_anims_direction_dict[curr_persona_name] = "r";
						} else if (curr_persona.body.x > target_x) {
							curr_persona.body.x -= movement_speed;
							anims_direction = "l";
							pre_anims_direction = "l";
							pre_anims_direction_dict[curr_persona_name] = "l";
						} else if (curr_persona.body.y < target_y) {
							curr_persona.body.y += movement_speed;
							anims_direction = "d";
							pre_anims_direction = "d";
							pre_anims_direction_dict[curr_persona_name] = "d";
						} else if (curr_persona.body.y > target_y) {
							curr_persona.body.y -= movement_speed;
							anims_direction = "u";
							pre_anims_direction = "u";
							pre_anims_direction_dict[curr_persona_name] = "u";
						} else {
							anims_direction = "";
						}

						curr_pronunciatio.x = curr_persona.body.x - PERSONA_LABEL_OFFSET_X;
						curr_pronunciatio.y = curr_persona.body.y - PERSONA_LABEL_OFFSET_X - PERSONA_LABEL_OFFSET_Y;

						let left_walk_name = curr_persona_name + "-left-walk";
						let right_walk_name = curr_persona_name + "-right-walk";
						let down_walk_name = curr_persona_name + "-down-walk";
						let up_walk_name = curr_persona_name + "-up-walk";

						if (anims_direction == "l") {
							curr_persona.anims.play(left_walk_name, true);
						} else if (anims_direction == "r") {
							curr_persona.anims.play(right_walk_name, true);
						} else if (anims_direction == "u") {
							curr_persona.anims.play(up_walk_name, true);
						} else if (anims_direction == "d") {
							curr_persona.anims.play(down_walk_name, true);
						}
					}
				}
			} else {
				if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture(curr_persona_name, "left");
				else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture(curr_persona_name, "right");
				else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture(curr_persona_name, "up");
				else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture(curr_persona_name, "down");
				curr_persona.anims.stop();

				finished = true;
				btnRun.textContent = "[Replay finished]";
				btnPause.style.display = "none";
			}
		}

		if (execute_count == 0) {
			for (let i = 0; i < Object.keys(personas).length; i++) {
				let curr_persona_name = Object.keys(personas)[i];
				let curr_persona = personas[curr_persona_name];
				if (movement_target[curr_persona_name]) {
					curr_persona.body.x = movement_target[curr_persona_name][0];
					curr_persona.body.y = movement_target[curr_persona_name][1];
				}
			}
			execute_count = execute_count_max + 1;
			step = step + 1;

			start_datetime = new Date(start_datetime.getTime() + step_size);
			if (currentTimeLabel) {
				currentTimeLabel.textContent = start_datetime.toLocaleTimeString("en-US", datetime_options);
			}
		}

		execute_count -= 1;
	}
</script>
